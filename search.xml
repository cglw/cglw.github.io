<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[08栈：如何实现浏览器的前进和后退功能？]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%A0%88%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一、什么是栈？ 后进者先出，先进者后出，这就是典型的“栈”结构。 从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据。 二、为什么需要栈？ 栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。 任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。 所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。 三、如何实现栈？ 栈的API 123456789101112public class Stack&lt;Item&gt; &#123;//压栈public void push(Item item)&#123;&#125;//弹栈public Item pop()&#123;&#125;//是否为空public boolean isEmpty()&#123;&#125;//栈中数据的数量public int size()&#123;&#125;//返回栈中最近添加的元素而不删除它public Item peek()&#123;&#125;&#125; 数组实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class StackOfArray&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; //存储数据的数组 Item[] a = (Item[]) new Object[1]; //记录元素个数N int N = 0; //构造器 public StackOfArray() &#123; &#125; //添加元素 public void push(Item item) &#123; //自动扩容 if (N == a.length) resize(2 * a.length); a[N++] = item; &#125; //删除元素 public Item pop() &#123; Item item = a[--N]; a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item; &#125; //是否为空 public boolean isEmpty() &#123; return N == 0; &#125; //元素个数 public int size() &#123; return N; &#125; //改变数组容量 private void resize(int length) &#123; Item[] temp = (Item[]) new Object[length]; for (int i = 0; i &lt; N; i++) &#123; temp[i] = a[i]; &#125; a = temp; &#125; //返回栈中最近添加的元素而不删除它 public Item peek() &#123; return a[N - 1]; &#125; @Override public Iterator&lt;Item&gt; iterator() &#123; return new ArrayIterator(); &#125; //内部类 class ArrayIterator implements Iterator &#123; //控制迭代数量 int i = N; @Override public boolean hasNext() &#123; return i &gt; 0; &#125; @Override public Item next() &#123; return a[--i]; &#125; &#125; &#125; 链表实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class StackOfLinked&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; //定义一个内部类，就可以直接使用类型参数 private class Node &#123; Item item; Node next; &#125; private Node first; private int N; //构造器 public StackOfLinked() &#123; &#125; //添加 public void push(Item item) &#123; Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; &#125; //删除 public Item pop() &#123; Item item = first.item; first = first.next; N--; return item; &#125; //是否为空 public boolean isEmpty() &#123; return N == 0; &#125; //元素数量 public int size() &#123; return N; &#125; //返回栈中最近添加的元素而不删除它 public Item peek() &#123; return first.item; &#125; @Override public Iterator&lt;Item&gt; iterator() &#123; return new LinkedIterator(); &#125; //内部类：迭代器 class LinkedIterator implements Iterator &#123; int i = N; Node t = first; @Override public boolean hasNext() &#123; return i &gt; 0; &#125; @Override public Item next() &#123; Item item = (Item) t.item; t = t.next; i--; return item; &#125; &#125; &#125; 四、栈的应用 栈在函数调用中的应用 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。 栈在表达式求值中的应用（比如：34+13*9+44-12/3） 利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。 栈在括号匹配中的应用（比如：{}{()}） 用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。 实现浏览器的前进后退功能？ 我们使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了。 五、思考 1. 我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？ 函数的调用符合先进后出，后进先出。函数中的局部变量，先定义的变量的生命周期比较长，后进入的比较短。函数的执行，只能内部的函数执行完了，外部的函数才会执行 2.我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？ 答：JVM里面的栈和我们这里说的是一回事，被称为方法栈。和前面函数调用的作用是一致的，用来存储方法中的局部变量]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[07链表（下）]]></title>
    <url>%2F2019%2F05%2F05%2F07%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[如何轻松写出正确的链表代码？一、理解指针或引用的含义1.含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用） 2.示例： p—&gt;next = q; 表示p节点的后继指针存储了q节点的内存地址。 p—&gt;next = p—&gt;next—&gt;next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。 二、警惕指针丢失和内存泄露1.插入节点 在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：p—&gt;next = x;x—&gt;next = p—&gt;next; 显然这会导致x节点的后继指针指向自身。正确的写法是2句代码交换顺序，即：x—&gt;next = p—&gt;next; p—&gt;next = x; 2.删除节点 在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：p—&gt;next = p—&gt;next—&gt;next; 三、使用哨兵简化什么是“哨兵”？ 链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。 引入“哨兵”的情况？ “哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。 “哨兵”还有哪些应用场景 四、重点留意边界条件处理经常用来检查链表是否正确的边界4个边界条件： 如果链表为空时，代码是否能正常工作？ 如果链表只包含一个节点时，代码是否能正常工作？ 如果链表只包含两个节点时，代码是否能正常工作？ 代码逻辑在处理头尾节点时是否能正常工作？五、举例画图，辅助思考 六、多写多练，没有捷径常见的链表操作： 单链表反转 链表中环的检测 两个有序链表合并 删除链表倒数第n个节点 求链表的中间节点 链表的交点]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android高级架构学习图谱]]></title>
    <url>%2F2019%2F04%2F09%2FAndroid%E9%AB%98%E7%BA%A7%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%9B%BE%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[layerlayout]]></title>
    <url>%2F2019%2F04%2F08%2Flayerlayout%2F</url>
    <content type="text"><![CDATA[我们先来看一个需求 需求大家先稍微思考一下这个布局怎么实现。 我想很多人首先想到的用Relativelayout或者Framlayout。红色框高度是不固定，那么我们需要等待页面加载数据完成，然后计算红色框的高度，再设置好下面输入框的marginTop，好像也不难，但是每次遇到这样的需求就得计算，感觉有点麻烦，我在想有没有更简单的方法。 首先大家可以发现两个view有固定的位置关系，就是下面的输入框头部 距离红色框底部是一个固定的-marginTop。我们直接用Linearlayout 放这两个view，上面红色框，下面编辑框， 我们平时用的Linearlayout、RelativeLayout等布局绘制子view的顺序是按照从上到下，后加入的先进行绘制，这样的视图层次，但是有的时候我们会遇到view是后加入的，却想绘制在先加入的view的视图层次下面。 实现思路:1.获取view的布局层次2.根据view的布局层次排序，改变view的绘制顺序 我们先解决第一个问题,如何为view加一个布局层次的属性。我们很容易想到在ViewGroup中，view 有属性grivate这样的属性。我们需要了解这样的属性是怎么加上去的。 第一步：添加一个layer属性在res/values文件夹加上attrs.xml文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;LayerParams&quot;&gt; &lt;!-- 自定义的属性名称 和对应的单位 --&gt; &lt;attr name=&quot;layer&quot; format=&quot;integer&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 第二步：继承已有的LayoutParams，加载属性1234567891011121314151617181920public class LayerLinLayoutParams extends LinearLayout.LayoutParams &#123; int layer = 0; public LayerLinLayoutParams(Context c, AttributeSet attrs) &#123; super(c, attrs); TypedArray a = c.obtainStyledAttributes(attrs, R.styleable.LayerParams); //获取设置在子控件上的位置属性 layer = a.getInt(R.styleable.LayerParams_layer, 0); a.recycle(); &#125; public LayerLinLayoutParams(int width, int height) &#123; super(width, height); &#125; public LayerLinLayoutParams(ViewGroup.LayoutParams source) &#123; super(source); &#125;&#125; 第三步：需要重写generateLayoutParams三个方法123456789101112131415161718public class LayerLinearLayout extends LinearLayout &#123; //构造方法 ... @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new LayerLinLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp) &#123; return new LayerLinLayoutParams(lp); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new LayoutParams(LayerLinLayoutParams.WRAP_CONTENT, LayerLinLayoutParams.WRAP_CONTENT); &#125;&#125; 这样我们就可以获取view的LayoutParams，就可以获取到layer属性的值。 解决了第一个问题，我们现在需要根据view的layer值进行更改绘制顺序 我们先看下源码绘制view流程123456789101112131415161718192021222324252627282930313233343536@Overrideprotected void dispatchDraw(Canvas canvas) &#123; boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode); //子view的count final int childrenCount = mChildrenCount; //子view的集合 final View[] children = mChildren; int flags = mGroupFlags; ... //依次遍历，绘制view for (int i = 0; i &lt; childrenCount; i++) &#123; while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123; final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; transientIndex = -1; &#125; &#125; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; ... &#125; 看了源码，我们可以知道view的绘制的先后顺序，由这个mChildren 决定，那么我们是不是可以在绘制前修改mChildren集合里面的view顺序，实现绘制先后顺序，从而改变绘制的图层。绘制后我们再恢复mChildren里面view的顺序，不影响其他地方执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class LayerLinearLayout extends LinearLayout &#123; //之前的代码 ... //重写dispatchDraw方法 @Override protected void dispatchDraw(Canvas canvas) &#123; orderChildrenByLayer(); super.dispatchDraw(canvas); reSetChildren(); &#125; public void orderChildrenByLayer() &#123; View[] mChildren = null; int mChildrenCount = getChildCount(); try &#123; fieldChildren = this.getClass().getSuperclass().getSuperclass().getDeclaredField(&quot;mChildren&quot;); fieldChildren.setAccessible(true); //反射获得view集合 mChildren = (View[]) fieldChildren.get(this); //保存绘制前的mChildren 为了绘制完恢复 mChildren starChildren = Arrays.copyOf(mChildren, mChildren.length); //根据layer 排序 sortChildren = Arrays.copyOf(mChildren, mChildrenCount); Arrays.sort(sortChildren, new ViewComparator()); //排序好的sortChildren，赋值给 mChildren,为了跟原长度一致 fieldChildren.set(this, Arrays.copyOf(sortChildren, mChildren.length)); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; public void reSetChildren() &#123; //恢复mChildren if (starChildren != null &amp;&amp; fieldChildren != null) &#123; try &#123; fieldChildren.set(this, Arrays.copyOf(starChildren, starChildren.length)); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class ViewComparator implements Comparator&lt;View&gt; &#123; @Override //实现Comparator的compare方法,根据layer比较 public int compare(View view1, View view2) &#123; ViewGroup.LayoutParams layoutParams = view1.getLayoutParams(); ViewGroup.LayoutParams layoutParams2 = view2.getLayoutParams(); int view1_layer = 0, view2_layer = 0; if (layoutParams instanceof LayerRelLayoutParams) &#123; view1_layer = ((LayerRelLayoutParams) layoutParams).layer; &#125; if (layoutParams2 instanceof LayerLinLayoutParams) &#123; view2_layer = ((LayerLinLayoutParams) layoutParams2).layer; &#125; // TODO Auto-generated method stub return view1_layer - view2_layer; &#125; &#125; 首先反射获得mChildren starChildren保存获取到的mChildren sortChildren是排序后的，然后再copy给mChildren 执行绘制 恢复mChildren]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Binder]]></title>
    <url>%2F2019%2F04%2F01%2FBinder%2F</url>
    <content type="text"><![CDATA[进程间通信 Linux进程为了保护进程空间不被别的进程破坏或者干扰，Linux中的进程是相互独立的，也就是所谓的进程隔离。（而且一个进程的内存空间还被分为了用户空间和内核空间，二者也是相互隔离的。这里不做探讨）所以在Linux中，进程与进程之间是相互隔离的，而且进程中的用户和内核空间也是隔离的。 也就是说为了安全和独立，一个进程是不能直接操作或者访问另外一个进程的内存空间的。他们之间既然是隔离的，在需要通信、协作的时候就需要使用进程间通信技术（即IPC，也称跨进程通信），我们都知道Android框架是建立在Linux之上的，当然也会面对进程间通讯的问题。 为什么使用Binder在Linux系统中为了达到进程间通讯的目的，我们可以选用诸如管道、Socket等技术手段，那么为什么Android选用了Binder这种新型的IPC技术，放弃了原有成熟的技术呢？ 性能角度1由于在移动设备诸如省电等性能的考虑，广泛地使用进程间通讯对于通信机制的性能有严格的要求，Binder相对于传统的Socket、管道方式更加高效。Bidner数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，内存共享方式一次内存拷贝都不需要，但是实现起来难度高，复杂性大。 2.稳定性角度 1传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。 3.安全性角度12传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C/S架构，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限 Binder机制 IPC机制简单描述 代码执行过程假设你已经创建好服务端类MyService、客户端类MyClient。在客户端持有MyService的引用，并且调用了MyService的func函数，那么Android内部调用过程如下： 代码调用过程看了这个图以后，相信你对你的代码在调用远程进程函数时有个全局的认识。这张图有一点很重要，就是客户端当前线程会被挂起！因此，如果远程进程是执行长时间的运算，请不要使用主线程去调用远程函数，以防止ANR。 Binder的C/S架构上面一节我们对远程进程调用代码执行过程有个初步了解，在Android开发中，我们大量使用到了系统Service，比如媒体播放、各种传感器以及WindowManagerService等等等等（太多了~）。那么Android是怎么管理这些服务，并且让用户跨进程调用这些服务呢？首先我们看看调用系统服务的过程。在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册（即让ServiceManager管理）。客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，然后通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。 Binder驱动实现原理服务端跨进程的类都要继承Binder类。我们所持有的Binder引用(即服务端的类引用)并不是实际真实的远程Binder对象，我们的引用在Binder驱动里还要做一次映射。也就是说，设备驱动根据我们的引用对象找到对应的远程进程。客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数，transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存，把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数，这个函数也是属于Binder类。远程进程Binder对象执行完成后，将得到的写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。 Binder机制运用12345678//获取WindowManager服务引用WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); //布局参数layoutParams相关设置略...View view=LayoutInflater.from(getApplication()).inflate(R.layout.float_layout, null); //添加viewwm.addView(view, layoutParams);这段代码前面已经出现过。getSystemService(getApplication().WINDOW_SERVICE);函数内部原理就是向ServiceManager查询标识符为getApplication().WINDOW_SERVICE的远程对象的引用。即WindowManager对象的引用，这个引用的真正实现是WindowManager的某个代理。得到这个引用后，在调用addView时，真正的实现是在代理里面，代理把参数打包到Parcel对象中，然后调用transact函数（该函数继承自Binder），再触发Binder驱动的一系列调用过程]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Message.obtain()和handler.obtainMessage比较]]></title>
    <url>%2F2019%2F03%2F25%2Fhandler%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[handler.obtainMessage 源码1234public final Message obtainMessage() &#123; return Message.obtain(this); &#125; Message 源码1234567891011121314151617181920public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125;public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h; return m; &#125; handler.obtain 本质就是调用Message的 Message.obtain 源码分析（以下截取关键部分）obtain 取Message的时候是从一个缓存的链表中取出 12345678910111213141516171819202122232425262728/*package*/ Message next; //用于加锁 private static final Object sPoolSync = new Object(); //缓存消息池子 private static Message sPool; //缓存池大小 private static int sPoolSize = 0; //最多缓存数量 private static final int MAX_POOL_SIZE = 50; /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; Message的回收，回收的时候判断当前缓存池长度是不是小于最大长度，那么吧当前Message放在缓存链表的头部 1234567891011121314151617181920212223void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[volatile跟synchronized]]></title>
    <url>%2F2019%2F03%2F20%2F%E8%B7%9Fsynchronized%2F</url>
    <content type="text"><![CDATA[线程安全造成线程安全问题的主要诱因有两点，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。 当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁， volatile 综上，volatile关键字的作用是：使变量在多个线程间可见 线程的局部变量（可见性） 综上，仅靠volatile不能保证线程的安全性。volatile修饰的变量并不保证对它的操作（自增）具有原子性 volatile关键字修饰的变量不会被指令重排序优化12345678910111213141516171819202122如果initialized变量不用 volatile 修饰，在线程A执行的代码中就有可能指令重排序。Map configOptions ;char[] configText;volatile boolean initialized = false;//线程A首先从文件中读取配置信息,调用process...处理配置信息,处理完成了将initialized 设置为trueconfigOptions = new HashMap();configText = readConfigFile(fileName);processConfig(configText, configOptions);//负责将配置信息configOptions 成功初始化initialized = true;while(!initialized)&#123; sleep();&#125;//使用配置信息干活doSomethingWithConfig(); synchronized如果一个类中有多个synchronized修饰的同步方法，且多个线程持有该类的同一个对象（该类的相同的对象），尽管它们调用不同的方法，各个方法的执行也是同步的。 如果各个同步的方法之间没有共享变量，或者说各个方法之间没有联系，但也只能同步执行，这会影响效率。 synchronized的三种应用方式 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 2.synchronized底层语义原理 Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键 实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。 而对于顶部，则是Java头对象，它实现synchronized的锁对象的基础，这点我们重点分析它，一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下表： 虚拟机位数 头对象结构 说明 32/64bit Mark Word 存储对象的hashCode、锁信息或分代年龄或GC标志等信息 32/64bit Class Metadata Address 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 重要的特性 synchronized的可重入性从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性 可重入锁：原因 有可能方法也会被多个地方调用 线程中断与synchronized 等待唤醒机制与synchronized 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态， 比较①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法 ②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。 synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。 四，线程安全性 线程安全性包括两个方面，①可见性。②原子性。 从上面自增的例子中可以看出：仅仅使用volatile并不能保证线程安全性。而synchronized则可实现线程的安全性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nginx403错误总结]]></title>
    <url>%2F2019%2F03%2F15%2Fnginx403%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.文件权限问题chmod 777 你的文件 2.配置的默认文件查看有没有例如查看有没有index.html，或者自己配置的 3.所有权限都是777的情况下任然无法访问关闭SELinux的方法： 临时关闭： 使用命令setenforce 0 永久关闭： 修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。 相关信息：SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。SELinux 默认安装在 Fedora 和 Red Hat Enterprise Linux 上，也可以作为其他发行版上容易安装的包得到。对访问的控制彻底化MAC(Mandatory Access Control） 对于所有的文件，目录，端口这类的资源的访问，都可以是基于策略设定的，这些策略是由管理员定制的、一般用户是没有权限更改的。TE （Type Enforcement）– 对于进程只赋予最小的权限 Te概念在 SELinux里非常的重要。它的特点是对所有的文件都赋予一个叫type的文件类型标签，对于所有的进程也赋予各自的一个叫 domain的 标签。Domain标签能够执行的操作也是由access vector在策略里定好的。domain迁移 –防止权限升级对于用户只赋予最小的权限]]></content>
      <categories>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java的Object类相关]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E7%9A%84Object%E7%B1%BB%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[hashcode() 快速比较对象的 equals() 比较对象的值1231.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！ String涉及到的常量池概念，1234567891011121314151617String s0 = &quot;111&quot;; //pool String s1 = new String(&quot;111&quot;); //heap final String s2 = &quot;111&quot;; //pool String s3 = &quot;sss111&quot;; //pool String s4 = &quot;sss&quot; + &quot;111&quot;; //pool String s5 = &quot;sss&quot; + s0; //heap String s6 = &quot;sss&quot; + s1; //heap String s7 = &quot;sss&quot; + s2; //pool String s8 = &quot;sss&quot; + s0; //heap System.out.println(s3 == s4); //true System.out.println(s3 == s5); //false System.out.println(s3 == s6); //false System.out.println(s3 == s7); //true System.out.println(s5 == s6); //false System.out.println(s5 == s8); //false 1.简单的说 但凡new的都是 在堆中 2.final 修饰的字符串会加入到常量池 3.字符串相加是链接在一起的，跟对象相关， 4.常量池字符串相加是在编译期间就已经加入进去了 Serializable 和Parcelable 的区别序列化 (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。（二进制流） why? 1）永久性保存对象，保存对象的字节序列到本地文件中； 2）通过序列化对象在网络中传递对象； 3）通过序列化在进程间传递对象。 区别： android上应该尽量采用Parcelable，效率至上 编码上： Serializable代码量少，写起来方便 Parcelable代码多一些 效率上： Parcelable的速度比Serializable 高十倍以上 serializable的迷人之处在于你只需要对某个类以及它的属性实现Serializable 接口即可。Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。 这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。 Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安卓内存优化]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%AE%89%E5%8D%93%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.内存问题造成的两个主要问题 异常在不同内存大小的设备异常率跟崩溃率差距很大 卡顿 发送SIGQUIT 信号获得 ANR 日志 Vss 虚拟内存PSS 物理内存Java 堆 systrace来观察gc性能耗时除了GC造成的卡顿外，物理内存不足系统会触发low memory killer 机制，负载过高是造成卡顿的另外一个原因 2.两个误区 误区一：内存占用越少越好希望做到 用时分配，及时释放 现在的手机以及有6G 8g甚至12G的， Android3.0之前bitmap对象在java堆，像素数据放在native内存，如果不手动调用recycle,bitmap native内存完全以来finalize（[ˈfaɪnəlaɪz] ），这个时机不太可控制 Android3.0-Android8.0讲bitmap对象跟像素，这样有个好处就是我们不用主动去调用recycle，Bitmap会被系统自动回收，不过bitmap是内存消耗大户，放在java堆中似乎不是很合适。Mate20,java堆限制最多512M,甚至我的手机还剩5g内存，但还是会oom,bitmap放在java堆中会引起大量的gC,对系统的内存完全没有利用起来 android 8.0 NativeAllocationRegister 实现了bitmap 内存放在native ,可以做到跟对象一起释放，同时Gc时候防止内存被滥用Android 8.0还新增了硬件位图，Hardware bitmap,减少图片内存，并提升绘制效率 误区二：Native内存不用管具体内容待调研 内存优化方向 设备分级 设备分级 低端机加载565的图片，不去使用动画，使用更小的内存缓存 缓存管理 统一的缓存管理机制，OnTrimMemory回调，根据不同的状态决定释放多少内存 进程模型 减少开启进程，减少常驻进程 安装包大小 80M的应用很难在512M内存的手机运行，可以推出lite版本 bitmap优化 根据imageview大小去加载图片 使用统一图片库，收拢图片的调用，这样可以做整体的控制策略 统一监控 大图片监控 重复图片监控 图片总内存 在oom 吧图片总内存，Top n图片的内存写到崩溃日志，帮助排查 内存泄漏 Java内存泄漏 可使用LeakCanary自动检测方案 OOM监控 Native内存监控 针对无法重编的so情况 PLT hook 拦截库的内存分配函数 针对可重编的so情况 通过 GCC 的“-finstrument-functions”参数给所有函数插桩，桩中模拟调用栈入栈出栈操作；通过 ld 的“–wrap”参数拦截内存分配和释放函数，重定向到我们自己的实现后记录分配的内存地址、大小、来源 so 以及插桩记录的调用栈此刻的内容，定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的App一些优化方案]]></title>
    <url>%2F2019%2F03%2F08%2FAndroid%E7%9A%84App%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1.为什么要优化 优化用户体验 优化方面: App启动速度UI流畅度内存优化apk瘦身电量优化网络速度优化App启动速度 利用TraceView分析启动时间 Application 构造方法，attachBaseContext()、onCreate() 尽量不做耗时初始化，可以异步初始化可以放在service 获取本地数据异步加载 对于MainActivity，由于在获取到第一帧前，需要对contentView进行测量布局绘制操作，尽量减少布局的层次，考虑ViewStub的延迟加载策略，当然在onCreate、onStart、onResume方法中避免做耗时操作。 为启动页加上背景 UI流畅度 一般就是不要在主进程去做耗时的操作，提升UI的绘制速度（减少View的布局层级，避免过渡绘制等） HierarchyViewer [ˈhaɪərɑ:ki] 内存优化 消除应用中的内存泄露、避免内存抖动 常用工具就是AS自带的内存检测，可以很好的发现内存抖动；leakcanary （[kəˈneəri]） 可以非常方便的帮助我们发现内存泄露； 常见内存泄漏 单例导致内存泄漏 单例持有activity的引用静态变量导致内存泄露 一个静态变量持有activity 尽量减少静态持有变量， 适当的时候重置nullpublic class MainActivity extends AppCompatActivity { private static Info sInfo; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (sInfo != null) { sInfo = new Info(this); } } } class Info { public Info(Activity activity) { }} 非静态内部类导致内存泄露 最常见的handler handler 持有activity 引用在activity ondestory 调用handler 移除回调跟message 静态内部类+弱引用 未取消注册或者回调 广播没有注销 Timer和TimerTask导致内存泄露 mTimer取消 mTimerTask.cancel();属性动画造成内存泄露 需要取消 集合中的对象未清理造成内存泄露 当我们不再需要这个对象时，也并没有将它从集合中移除，这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象更会造成内存泄露了。所以在使用集合时要及时将不用的对象从集合remove，或者clear集合，以避免内存泄漏。 资源未关闭或释放导致内存泄露 在使用IO、File流或者Sqlite、Cursor等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果及时不关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。 WebView造成内存泄露 Webview下面的Callback持有Activity引用 在销毁WebView之前需要先将WebView从父容器中移除，然后在销毁WebView。 @Overrideprotected void onDestroy() { super.onDestroy(); // 先从父控件中移除WebView mWebViewContainer.removeView(mWebView); mWebView.stopLoading(); mWebView.getSettings().setJavaScriptEnabled(false); mWebView.clearHistory(); mWebView.removeAllViews(); mWebView.destroy();} 关于Apk瘦身，主要由以下几个方式： 利用ProGuard压缩代码去除无用资源andresguard进一步压缩与混淆资源so的优化与配置，只保留一类so合理配置去除不必要的配置，仅保留中文配置等…混合开发电量优化 通过监听设备的状态: 休眠状态 充电状态 网络状态以让我们将一些操作放在充电或是电量足够的情况下进行, 以提升用户体验. 例如用户数据同步, Log上传等. 谨慎使用WakeLock定位中使用GPS, 请记得及时关闭 减少更新频率 根据实际情况选择GPS或网络或两者. 只使用一个会降低电量损耗. 4.网络优化 减少请求频率，请求数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android的View绘制流程]]></title>
    <url>%2F2019%2F03%2F03%2FAndroid%E7%9A%84View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述本篇文章会从源码（基于Android 6.0）角度分析Android中View的绘制流程，侧重于对整体流程的分析，对一些难以理解的点加以重点阐述，目的是把View绘制的整个流程把握好，而对于特定实现细节则可以日后再对相应源码进行研读。在进行实际的分析之前，我们先来看下面这张图： 我们来对上图做出简单解释：DecorView是一个应用窗口的根容器，它本质上是一个FrameLayout。DecorView有唯一一个子View，它是一个垂直LinearLayout，包含两个子元素，一个是TitleView（ActionBar的容器），另一个是ContentView（窗口内容的容器）。关于ContentView，它是一个FrameLayout（android.R.id.content)，我们平常用的setContentView就是设置它的子View。上图还表达了每个Activity都与一个Window（具体来说是PhoneWindow）相关联，用户界面则由Window所承载。 WindowWindow即窗口，这个概念在Android Framework中的实现为android.view.Window这个抽象类，这个抽象类是对Android系统中的窗口的抽象。在介绍这个类之前，我们先来看看究竟什么是窗口呢？ 实际上，窗口是一个宏观的思想，它是屏幕上用于绘制各种UI元素及响应用户输入事件的一个矩形区域。通常具备以下两个特点： 独立绘制，不与其它界面相互影响；不会触发其它界面的输入事件；在Android系统中，窗口是独占一个Surface实例的显示区域，每个窗口的Surface由WindowManagerService分配。我们可以把Surface看作一块画布，应用可以通过Canvas或OpenGL在其上面作画。画好之后，通过SurfaceFlinger将多块Surface按照特定的顺序（即Z-order）进行混合，而后输出到FrameBuffer中，这样用户界面就得以显示。 android.view.Window这个抽象类可以看做Android中对窗口这一宏观概念所做的约定，而PhoneWindow这个类是Framework为我们提供的Android窗口概念的具体实现。接下来我们先来介绍一下android.view.Window这个抽象类。 这个抽象类包含了三个核心组件： WindowManager.LayoutParams: 窗口的布局参数；Callback: 窗口的回调接口，通常由Activity实现；ViewTree: 窗口所承载的控件树。下面我们来看一下Android中Window的具体实现（也是唯一实现）——PhoneWindow。 PhoneWindow前面我们提到了，PhoneWindow这个类是Framework为我们提供的Android窗口的具体实现。我们平时调用setContentView()方法设置Activity的用户界面时，实际上就完成了对所关联的PhoneWindow的ViewTree的设置。我们还可以通过Activity类的requestWindowFeature()方法来定制Activity关联PhoneWindow的外观，这个方法实际上做的是把我们所请求的窗口外观特性存储到了PhoneWindow的mFeatures成员中，在窗口绘制阶段生成外观模板时，会根据mFeatures的值绘制特定外观。 从setContentView()说开去在分析setContentView()方法前，我们需要明确：这个方法只是完成了Activity的ContentView的创建，而并没有执行View的绘制流程。当我们自定义Activity继承自android.app.Activity时候，调用的setContentView()方法是Activity类的，源码如下：1234567891011121314151617181920212223242526272829303132333435public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); . . .&#125;getWindow()方法会返回Activity所关联的PhoneWindow，也就是说，实际上调用到了PhoneWindow的setContentView()方法，源码如下：@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; // mContentParent即为上面提到的ContentView的父容器，若为空则调用installDecor()生成 installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; // 具有FEATURE_CONTENT_TRANSITIONS特性表示开启了Transition // mContentParent不为null，则移除decorView的所有子View mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; // 开启了Transition，做相应的处理，我们不讨论这种情况 // 感兴趣的同学可以参考源码 . . . &#125; else &#123; // 一般情况会来到这里，调用mLayoutInflater.inflate()方法来填充布局 // 填充布局也就是把我们设置的ContentView加入到mContentParent中 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; . . . // cb即为该Window所关联的Activity final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; // 调用onContentChanged()回调方法通知Activity窗口内容发生了改变 cb.onContentChanged(); &#125; . . .&#125; LayoutInflater.inflate()在上面我们看到了，PhoneWindow的setContentView()方法中调用了LayoutInflater的inflate()方法来填充布局，这个方法的源码如下：1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null);&#125;public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); . . . final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 在PhoneWindow的setContentView()方法中传入了decorView作为LayoutInflater.inflate()的root参数，我们可以看到，通过层层调用，最终调用的是inflate(XmlPullParser, ViewGroup, boolean)方法来填充布局。这个方法的源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; . . . final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. int type; // 一直读取xml文件，直到遇到开始标记 while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; // 最先遇到的不是开始标记，报错 if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription()+ &quot;: No start tag found!&quot;); &#125; final String name = parser.getName(); . . . // 单独处理&lt;merge&gt;标签，不熟悉的同学请参考官方文档的说明 if (TAG_MERGE.equals(name)) &#123; // 若包含&lt;merge&gt;标签，父容器（即root参数）不可为空且attachRoot须为true，否则报错 if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;+ &quot;ViewGroup root and attachToRoot=true&quot;); &#125; // 递归地填充布局 rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // temp为xml布局文件的根View final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; . . . // 获取父容器的布局参数（LayoutParams） params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // 若attachToRoot参数为false，则我们只会将父容器的布局参数设置给根View temp.setLayoutParams(params); &#125; &#125; // 递归加载根View的所有子View rInflateChildren(parser, temp, attrs, true); . . . if (root != null &amp;&amp; attachToRoot) &#123; // 若父容器不为空且attachToRoot为true，则将父容器作为根View的父View包裹上来 root.addView(temp, params); &#125; // 若root为空或是attachToRoot为false，则以根View作为返回值 if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; . . . &#125; catch (Exception e) &#123; . . . &#125; finally &#123; . . . &#125; return result; &#125;&#125; 在上面的源码中，首先对于布局文件中的标签进行单独处理，调用rInflate()方法来递归填充布局。这个方法的源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; // 获取当前标记的深度，根标记的深度为0 final int depth = parser.getDepth(); int type; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // 不是开始标记则继续下一次迭代 if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); // 对一些特殊标记做单独处理 if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123; throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); &#125; // 对&lt;include&gt;做处理 parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); &#125; else &#123; // 对一般标记的处理 final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params=viewGroup.generateLayoutParams(attrs); // 递归地加载子View rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125; 我们可以看到，上面的inflate()和rInflate()方法中都调用了rInflateChildren()方法，这个方法的源码如下： final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException { rInflate(parser, parent, parent.getContext(), attrs, finishInflate);}从源码中我们可以知道，rInflateChildren()方法实际上调用了rInflate()方法。 到这里，setContentView()的整体执行流程我们就分析完了，至此我们已经完成了Activity的ContentView的创建与设置工作。接下来，我们开始进入正题，分析View的绘制流程。 ViewRootImpl在介绍View的绘制前，首先我们需要知道是谁负责执行View绘制的整个流程。实际上，View的绘制是由ViewRoot来负责的。每个应用程序窗口的decorView都有一个与之关联的ViewRoot对象，这种关联关系是由WindowManager来维护的。 那么decorView与ViewRoot的关联关系是在什么时候建立的呢？答案是Activity启动时，ActivityThread.handleResumeActivity()方法中建立了它们两者的关联关系。这里我们不具体分析它们建立关联的时机与方式，感兴趣的同学可以参考相关源码。下面我们直入主题，分析一下ViewRoot是如何完成View的绘制的。 View绘制的起点当建立好了decorView与ViewRoot的关联后，ViewRoot类的requestLayout()方法会被调用，以完成应用程序用户界面的初次布局。实际被调用的是ViewRootImpl类的requestLayout()方法，这个方法的源码如下：123456789@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; // 检查发起布局请求的线程是否为主线程 checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 上面的方法中调用了scheduleTraversals()方法来调度一次完成的绘制流程，该方法会向主线程发送一个“遍历”消息，最终会导致ViewRootImpl的performTraversals()方法被调用。下面，我们以performTraversals()为起点，来分析View的整个绘制流程。 三个阶段View的整个绘制流程可以分为以下三个阶段： measure: 判断是否需要重新计算View的大小，需要的话则计算；layout: 判断是否需要重新计算View的位置，需要的话则计算；draw: 判断是否需要重新绘制View，需要的话则重绘制。这三个子阶段可以用下图来描述：measure阶段此阶段的目的是计算出控件树中的各个控件要显示其内容的话，需要多大尺寸。起点是ViewRootImpl的measureHierarchy()方法，这个方法的源码如下：1234567891011121314151617181920private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) &#123; // 传入的desiredWindowXxx为窗口尺寸 int childWidthMeasureSpec; int childHeightMeasureSpec; boolean windowSizeMayChange = false; . . . boolean goodMeasure = false; if (!goodMeasure) &#123; childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123; windowSizeMayChange = true; &#125; &#125; return windowSizeMayChange;&#125; 上面的代码中调用getRootMeasureSpec()方法来获取根MeasureSpec，这个根MeasureSpec代表了对decorView的宽高的约束信息。继续分析之前，我们先来简单地介绍下MeasureSpec的概念。MeasureSpec是一个32位整数，由SpecMode和SpecSize两部分组成，其中，高2位为SpecMode，低30位为SpecSize。SpecMode为测量模式，SpecSize为相应测量模式下的测量尺寸。View（包括普通View和ViewGroup）的SpecMode由本View的LayoutParams结合父View的MeasureSpec生成。SpecMode的取值可为以下三种： EXACTLY: 对子View提出了一个确切的建议尺寸（SpecSize）；AT_MOST: 子View的大小不得超过SpecSize；UNSPECIFIED: 对子View的尺寸不作限制，通常用于系统内部。传入performMeasure()方法的MeasureSpec的SpecMode为EXACTLY，SpecSize为窗口尺寸。performMeasure()方法的源码如下：12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; . . . try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; . . . &#125;&#125; 上面代码中的mView即为decorView，也就是说会转向对View.measure()方法的调用，这个方法的源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 调用这个方法来算出一个View应该为多大。参数为父View对其宽高的约束信息。 * 实际的测量工作在onMeasure()方法中进行 */public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; . . . // 判断是否需要重新布局 // 若mPrivateFlags中包含PFLAG_FORCE_LAYOUT标记，则强制重新布局 // 比如调用View.requestLayout()会在mPrivateFlags中加入此标记 final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); final boolean needsLayout = specChanged &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); // 需要重新布局 if (forceLayout || needsLayout) &#123; . . . // 先尝试从缓从中获取，若forceLayout为true或是缓存中不存在或是 // 忽略缓存，则调用onMeasure()重新进行测量工作 int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); . . . &#125; else &#123; // 缓存命中，直接从缓存中取值即可，不必再测量 long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); . . . &#125; . . . &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension&#125; 从measure()方法的源码中我们可以知道，只有以下两种情况之一，才会进行实际的测量工作： forceLayout为true：这表示强制重新布局，可以通过View.requestLayout()来实现；needsLayout为true，这需要specChanged为true（表示本次传入的MeasureSpec与上次传入的不同），并且以下三个条件之一成立：sAlwaysRemeasureExactly为true: 该变量默认为false；isSpecExactly为false: 若父View对子View提出了精确的宽高约束，则该变量为true，否则为falsematchesSpecSize为false: 表示父View的宽高尺寸要求与上次测量的结果不同对于decorView来说，实际执行测量工作的是FrameLayout的onMeasure()方法，该方法的源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int count = getChildCount(); . . . int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); . . . &#125; &#125; // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground&apos;s minimum height and width final Drawable drawable = getForeground(); if (drawable != null) &#123; maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); &#125; setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); . . . &#125; FrameLayout是ViewGroup的子类，后者有一个View[]类型的成员变量mChildren，代表了其子View集合。通过getChildAt(i)能获取指定索引处的子View，通过getChildCount()可以获得子View的总数。 在上面的源码中，首先调用measureChildWithMargins()方法对所有子View进行了一遍测量，并计算出所有子View的最大宽度和最大高度。而后将得到的最大高度和宽度加上padding，这里的padding包括了父View的padding和前景区域的padding。然后会检查是否设置了最小宽高，并与其比较，将两者中较大的设为最终的最大宽高。最后，若设置了前景图像，我们还要检查前景图像的最小宽高。 经过了以上一系列步骤后，我们就得到了maxHeight和maxWidth的最终值，表示当前容器View用这个尺寸就能够正常显示其所有子View（同时考虑了padding和margin）。而后我们需要调用resolveSizeAndState()方法来结合传来的MeasureSpec来获取最终的测量宽高，并保存到mMeasuredWidth与mMeasuredHeight成员变量中。 从以上代码的执行流程中，我们可以看到，容器View通过measureChildWithMargins()方法对所有子View进行测量后，才能得到自身的测量结果。也就是说，对于ViewGroup及其子类来说，要先完成子View的测量，再进行自身的测量（考虑进padding等）。接下来我们来看下ViewGroup的measureChildWithMargins()方法的实现：123456789101112protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 由以上代码我们可以知道，对于ViewGroup来说，它会调用child.measure()来完成子View的测量。传入ViewGroup的MeasureSpec是它的父View用于约束其测量的，那么ViewGroup本身也需要生成一个childMeasureSpec来限制它的子View的测量工作。这个childMeasureSpec就由getChildMeasureSpec()方法生成。接下来我们来分析这个方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; // spec为父View的MeasureSpec // padding为父View在相应方向的已用尺寸加上父View的padding和子View的margin // childDimension为子View的LayoutParams的值 int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); // 现在size的值为父View相应方向上的可用大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; // 表示子View的LayoutParams指定了具体大小值（xx dp） resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // 子View想和父View一样大 resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // 子View想自己决定其尺寸，但不能比父View大 resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // 子View指定了具体大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // 子View想跟父View一样大，但是父View的大小未固定下来 // 所以指定约束子View不能比父View大 resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // 子View想要自己决定尺寸，但不能比父View大 resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; . . . &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 上面的方法展现了根据父View的MeasureSpec和子View的LayoutParams生成子View的MeasureSpec的过程， 子View的LayoutParams表示了子View的期待大小。这个产生的MeasureSpec用于指导子View自身的测量结果的确定。在上面的代码中，我们可以看到当ParentMeasureSpec的SpecMode为EXACTLY时，表示父View对子View指定了确切的宽高限制。此时根据子View的LayoutParams的不同，分以下三种情况： 具体大小（childDimension）：这种情况下令子View的SpecSize为childDimension，即子View在LayoutParams指定的具体大小值；令子View的SpecMode为EXACTLY，即这种情况下若该子View为容器View，它也有能力给其子View指定确切的宽高限制（子View只能在这个宽高范围内），若为普通View，它的最终测量大小就为childDimension。match_parent：此时表示子View想和父View一样大。这种情况下得到的子View的SpecMode与上种情况相同，只不过SpecSize为size，即父View的剩余可用大小。wrap_content: 这表示了子View想自己决定自己的尺寸（根据其内容的大小动态决定）。这种情况下子View的确切测量大小只能在其本身的onMeasure()方法中计算得出，父View此时无从知晓。所以暂时将子View的SpecSize设为size（父View的剩余大小）；令子View的SpecMode为AT_MOST，表示了若子View为ViewGroup，它没有能力给其子View指定确切的宽高限制，毕竟它本身的测量宽高还悬而未定。当ParentMeasureSpec的SpecMode为AT_MOST时，我们也可以根据子View的LayoutParams的不同来分三种情况讨论： 具体大小：这时令子View的SpecSize为childDimension，SpecMode为EXACTLY。match_parent：表示子View想和父View一样大，故令子View的SpecSize为size，但是由于父View本身的测量宽高还无从确定，所以只是暂时令子View的测量结果为父View目前的可用大小。这时令子View的SpecMode为AT_MOST。wrap_content：表示子View想自己决定大小（根据其内容动态确定）。然而这时父View还无法确定其自身的测量宽高，所以暂时令子View的SpecSize为size，SpecMode为AT_MOST。从上面的分析我们可以得到一个通用的结论，当子View的测量结果能够确定时，子View的SpecMode就为EXACTLY；当子View的测量结果还不能确定（只是暂时设为某个值）时，子View的SpecMode为AT_MOST。在measureChildWithMargins()方法中，获取了知道子View测量的MeasureSpec后，接下来就要调用child.measure()方法，并把获取到的childMeasureSpec传入。这时便又会调用onMeasure()方法，若此时的子View为ViewGroup的子类，便会调用相应容器类的onMeasure()方法，其他容器View的onMeasure()方法与FrameLayout的onMeasure()方法执行过程相似。 下面会我们回到FrameLayout的onMeasure()方法，当递归地执行完所有子View的测量工作后，会调用resolveSizeAndState()方法来根据之前的测量结果确定最终对FrameLayout的测量结果并存储起来。View类的resolveSizeAndState()方法的源码如下：12345678910111213141516171819202122232425262728public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123; final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) &#123; case MeasureSpec.AT_MOST: if (specSize &lt; size) &#123; // 父View给定的最大尺寸小于完全显示内容所需尺寸 // 则在测量结果上加上MEASURED_STATE_TOO_SMALL result = specSize | MEASURED_STATE_TOO_SMALL; &#125; else &#123; result = size; &#125; break; case MeasureSpec.EXACTLY: // 若specMode为EXACTLY，则不考虑size，result直接赋值为specSize result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; &#125; return result | (childMeasuredState &amp; MEASURED_STATE_MASK);&#125; 对于普通View，会调用View类的onMeasure()方法来进行实际的测量工作，该方法的源码如下：1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 对于普通View（非ViewgGroup）来说，只需完成自身的测量工作即可。以上代码中通过setMeasuredDimension()方法设置测量的结果，具体来说是以getDefaultSize()方法的返回值来作为测量结果。getDefaultSize()方法的源码如下：123456789101112131415public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 由以上代码我们可以看到，View的getDefaultSize()方法对于AT_MOST和EXACTLY这两种情况都返回了SpecSize作为result。所以若我们的自定义View直接继承了View类，我们就要自己对wrap_content (对应了AT_MOST)这种情况进行处理，否则对自定义View指定wrap_content就和match_parent效果一样了。 layout阶段layout阶段的基本思想也是由根View开始，递归地完成整个控件树的布局（layout）工作。 View.layout()我们把对decorView的layout()方法的调用作为布局整个控件树的起点，实际上调用的是View类的layout()方法，源码如下：1234567891011121314public void layout(int l, int t, int r, int b) &#123; // l为本View左边缘与父View左边缘的距离 // t为本View上边缘与父View上边缘的距离 // r为本View右边缘与父View左边缘的距离 // b为本View下边缘与父View上边缘的距离 . . . boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); . . . &#125; . . .&#125; 这个方法会调用setFrame()方法来设置View的mLeft、mTop、mRight和mBottom四个参数，这四个参数描述了View相对其父View的位置（分别赋值为l, t, r, b），在setFrame()方法中会判断View的位置是否发生了改变，若发生了改变，则需要对子View进行重新布局，对子View的局部是通过onLayout()方法实现了。由于普通View（ 非ViewGroup）不含子View，所以View类的onLayout()方法为空。因此接下来，我们看看ViewGroup类的onLayout()方法的实现。 ViewGroup.onLayout()实际上ViewGroup类的onLayout()方法是abstract，这是因为不同的布局管理器有着不同的布局方式。这里我们以decorView，也就是FrameLayout的onLayout()方法为例，分析ViewGroup的布局过程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125;void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) &#123; gravity = DEFAULT_CHILD_GRAVITY; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) &#123; childLeft = parentRight - width - lp.rightMargin; break; &#125; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; &#125; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 +lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; 在上面的方法中，parentLeft表示当前View为其子View显示区域指定的一个左边界，也就是子View显示区域的左边缘到父View的左边缘的距离，parentRight、parentTop、parentBottom的含义同理。确定了子View的显示区域后，接下来，用一个for循环来完成子View的布局。在确保子View的可见性不为GONE的情况下才会对其进行布局。首先会获取子View的LayoutParams、layoutDirection等一系列参数。上面代码中的childLeft代表了最终子View的左边缘距父View左边缘的距离，childTop代表了子View的上边缘距父View的上边缘的距离。会根据子View的layout_gravity的取值对childLeft和childTop做出不同的调整。最后会调用child.layout()方法对子View的位置参数进行设置，这时便转到了View.layout()方法的调用，若子View是容器View，则会递归地对其子View进行布局。 到这里，layout阶段的大致流程我们就分析完了，这个阶段主要就是根据上一阶段得到的View的测量宽高来确定View的最终显示位置。显然，经过了measure阶段和layout阶段，我们已经确定好了View的大小和位置，那么接下来就可以开始绘制View了。 draw阶段对于本阶段的分析，我们以decorView.draw()作为分析的起点，也就是View.draw()方法，它的源码如下：123456789101112131415161718192021public void draw(Canvas canvas) &#123; . . . // 绘制背景，只有dirtyOpaque为false时才进行绘制，下同 int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; . . . // 绘制自身内容 if (!dirtyOpaque) onDraw(canvas); // 绘制子View dispatchDraw(canvas); . . . // 绘制滚动条等 onDrawForeground(canvas);&#125; 简单起见，在上面的代码中我们省略了实现滑动时渐变边框效果相关的逻辑。实际上，View类的onDraw()方法为空，因为每个View绘制自身的方式都不尽相同，对于decorView来说，由于它是容器View，所以它本身并没有什么要绘制的。dispatchDraw()方法用于绘制子View，显然普通View（非ViewGroup）并不能包含子View，所以View类中这个方法的实现为空。 ViewGroup类的dispatchDraw()方法中会依次调用drawChild()方法来绘制子View，drawChild()方法的源码如下：123protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 这个方法调用了View.draw(Canvas, ViewGroup，long)方法来对子View进行绘制。在draw(Canvas, ViewGroup, long)方法中，首先对canvas进行了一系列变换，以变换到将要被绘制的View的坐标系下。完成对canvas的变换后，便会调用View.draw(Canvas)方法进行实际的绘制工作，此时传入的canvas为经过变换的，在将被绘制View的坐标系下的canvas。 进入到View.draw(Canvas)方法后，会向之前介绍的一样，执行以下几步： 绘制背景;通过onDraw()绘制自身内容;通过dispatchDraw()绘制子View;绘制滚动条 总结1234graph LRA--&gt;BB--&gt;CC--&gt;A]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android的View相关]]></title>
    <url>%2F2019%2F03%2F01%2FAndroid%E7%9A%84View%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[绘制流程Measure -&gt; layout -&gt; draw View的测量的三种模式 EXACTLY [ɪgˈzæktli](精确的)。 固定的值或者match_parent填充 父亲布局 AT_MOST (最大值) wrap_content UNSPECIFIDE （un speci fide） (未确定). 在自定义控件 自定义view 默认 EXACTLY需要支持wrap_content 需要重写OnMeasure 12345678910111213141516171819202122public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measureWidth(widthMeasureSpec), measureWidth(heightMeasureSpec)); &#125; public int measureWidth(int measureSpec) &#123; int result = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize; &#125; else &#123; result = 200; if (specMode == MeasureSpec.AT_MOST) &#123; result = Math.min(specSize, result); &#125; &#125; return result; &#125; view的测量高度跟实际高度区别基本上百分之99的情况下都是可以认为没有区别的。有两种情况，有区别。第一种 就是有的时候会因为某些原因 view会多次测量，那第一次测量的宽高 肯定和最后实际的宽高 是不一定相等的，但是在这种情况下 最后一次测量的宽高和实际宽高是一致的。此外，实际宽高是在layout流程里确定的，我们可以在layout流程里 将实际宽高写死 写成硬编码，这样测量的宽高和实际宽高就肯定不一样了，虽然这么做没有意义 而且也不好。 MeasureSpecMeasureSpec代表一个32位int值，高2位代表SpecMode，低30位代表SpecSize，SpecMode是指测量模式，而specSize是指在某种测量模式下的规格大小。 MeasureSpec通过SpecMode和SpecSize打包成int值来避免过多对象内存分配，为了方便操作，其提供了打包和解包的方法。SpecModel和SpecSize也是一个int值，一组SpecMode和SpecSize可以打包为一个MeasureSpec，而一个MeasureSpec可以通过解包的形式来得出其原始的SpecMode和SpecSize，需要注意的是这里提到的MeasureSpec是指MeasureSpec所代表的int值，而并非MeasureSpec本身。 view的measureSpec 由谁决定?顶级view呢？由view自己的layoutparams和父容器 一起决定自己的measureSpec。一旦确定了spec，onMeasure中就可以确定view的宽高 顶级view就稍微特殊一点，对于decorView的测量在ViewRootImpl的源码里。 12345678910111213141516171819202122232425//desire的这2个参数就代表屏幕的宽高， childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); //decorView的measureSpec就是在这里确定的，其实比普通view的measurespec要简单的多 //代码就不分析了 一目了然的东西 private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&apos;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; 对于普通view来说，他的measure过程中，与父view有关吗？如果有关，这个父view也就是viewgroup扮演了什么角色？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this view * @param heightMeasureSpec The height requirements for this view */ protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; /** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding. * The heavy lifting is done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param parentHeightMeasureSpec The height requirements for this view */ protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125;/对于普通view的measure来说 是由这个view的 父view ，也就是viewgroup来触发的。//也就是下面这个measureChildWithMargins方法protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; //第一步 先取得子view的 layoutParams 参数值 final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //然后开始计算子view的spec的值，注意这里看到 计算的时候除了要用子view的 layoutparams参数以外 //还用到了父view 也就是viewgroup自己的spec的值 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125;//这个算view的spec的方法 看上去一大串 但是真的逻辑非常简单 就是根据父亲viewgroup//的meaurespec 同时还有view自己的params来确定 view自己的measureSpec。//注意这里的参数是padding,这个值的含义是 父容器已占用的控件的大小 所以view的Specsize//的值 你们可以看到 是要减去这个padding的值的。总大小-已经用的 =可用的。 很好理解。//然后就是下面的switch逻辑 要自己梳理清楚。其实也不难，主要是下面几条原则//如果view采用固定宽高，也就是写死的数值那种。那就不管父亲的spec的值了，view的spec 就肯定是exactly 并且大小遵循layout参数里设置的大小。//如果view的宽高是match_parent ，那么就要看父容器viewgroup的 spec的值了，如果父view的spec是exactly模式，//那view也肯定是exactly,并且大小就是父容器剩下的空间。如果父容器是at_most模式，那view也是at_most 并且不会超过剩余空间大小//如果view的宽高是wrap_content, 那就不管父容器的spec了，view的spec一定是at_most 并且不会超过父view 剩余空间的大小。public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 自定义view中 如果onMeasure方法 没有对wrap_content 做处理 会发生什么？为什么？怎么解决？如果没有对wrap_content做处理 ，那即使你在xml里设置为wrap_content.其效果也和match_parent相同。看问题4的分析。我们可以知道view自己的layout为wrap，那mode就是at_most（不管父亲view是什么specmode）. 这种模式下宽高就是等于specSize(getDefaultSize函数分析可知)，而这里的specSize显然就是parentSize的大小。也就是父容器剩余的大小。那不就和我们直接设置成match_parent是一样的效果了么？ 解决方式就是在onMeasure里 针对wrap 来做特殊处理 比如指定一个默认的宽高，当发现是wrap_content 就设置这个默认宽高即可。 ViewGroup有onMeasure方法吗？为什么?没有，这个方法是交给子类自己实现的。不同的viewgroup子类 肯定布局都不一样，那onMeasure索性就全部交给他们自己实现好了。 为什么在activity的生命周期里无法获得测量宽高？有什么方法可以解决这个问题吗？12345678910public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); if (hasFocus) &#123; int width = tv.getMeasuredWidth(); int height = tv.getMeasuredHeight(); Log.v(&quot;burning&quot;, &quot;width==&quot; + width); Log.v(&quot;burning&quot;, &quot;height==&quot; + height); &#125; &#125; 将一个runnable添加到Layout队列中：View.post()1234567891011Override protected void onStart() &#123; super.onStart(); tv.post(new Runnable() &#123; @Override public void run() &#123; int width = tv.getMeasuredWidth(); int height = tv.getMeasuredHeight(); &#125; &#125;); &#125; 监听view的视图树，这个方法会调用很多次的123456789101112view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); mScrollView.post(new Runnable() &#123; public void run() &#123; view.getHeight(); //height is ready &#125; &#125;); &#125; &#125;); 123measure(0,0)；或重新调用onmeasure方法，宽高的增加值为0 int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); layout和onLayout方法有什么区别？12protected abstract void onLayout(boolean changed, int l, int t, int r, int b); 该方法在ViewGroup中定义是抽象函数，继承该类必须实现onLayout方法，而ViewGroup的onMeasure并非必须重写的。View的放置都是根据一个矩形空间放置的，onLayout传下来的l,t,r,b分别是放置父控件的矩形可用空间（除去margin和padding的空间）的左上角的left、top以及右下角right、bottom值。1public void layout(int l, int t, int r, int b); 该方法是View的放置方法，在View类实现。调用该方法需要传入放置View的矩形空间左上角left、top值和右下角right、bottom值。这四个值是相对于父控件而言的。例如传入的是（10, 10, 100, 100），则该View在距离父控件的左上角位置(10, 10)处显示，显示的大小是宽高是90(参数r,b是相对左上角的)，这有点像绝对布局。 平常开发所用到RelativeLayout、LinearLayout、FrameLayout…这些都是继承ViewGroup的布局。这些布局的实现都是通过都实现ViewGroup的onLayout方法，只是实现方法不一样而已。 setWillNotDraw方法有什么用？12345678910111213/** * If this view doesn&apos;t do any drawing on its own, set this flag to * allow further optimizations. By default, this flag is not set on * View, but could be set on some View subclasses such as ViewGroup. * * Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125; * you should clear this flag. * * @param willNotDraw whether or not this View draw on its own */ public void setWillNotDraw(boolean willNotDraw) &#123; setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK); &#125; 用于设置标志位的 也就是说 如果你的自定义view 不需要draw的话，就可以设置这个方法为true。这样系统知道你这个view 不需要draw 可以优化执行速度。viewgroup 一般都默认设置这个为true，因为viewgroup多数都是只负责布局 不负责draw的。而view 这个标志位 默认一般都是关闭的]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node搭建本地服务器]]></title>
    <url>%2F2019%2F02%2F26%2Fnode%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[node 本地服务器搭建 一、安装node官网下载安装: http://nodejs.cn/ 二、新建文件1.新建 server.js12345678910111213141516171819202122232425262728293031323334353637383940414243var PORT = 3000;// var http = require(&apos;http&apos;);var url=require(&apos;url&apos;);var fs=require(&apos;fs&apos;);var mine=require(&apos;./mine&apos;).types;//var path=require(&apos;path&apos;); var server = http.createServer(function (request, response) &#123; var pathname = url.parse(request.url).pathname; var realPath = path.join(&quot;webapp&quot;, pathname); //这里设置自己的文件名称; var ext = path.extname(realPath); ext = ext ? ext.slice(1) : &apos;unknown&apos;; fs.exists(realPath, function (exists) &#123; if (!exists) &#123; response.writeHead(404, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); response.write(&quot;This request URL &quot; + pathname + &quot; was not found on this server.&quot;); response.end(); &#125; else &#123; fs.readFile(realPath, &quot;binary&quot;, function (err, file) &#123; if (err) &#123; response.writeHead(500, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); response.end(err); &#125; else &#123; var contentType = mine[ext] || &quot;text/plain&quot;; response.writeHead(200, &#123; &apos;Content-Type&apos;: contentType &#125;); response.write(file, &quot;binary&quot;); response.end(); &#125; &#125;); &#125; &#125;);&#125;);server.listen(PORT);console.log(&quot;Server runing at port: &quot; + PORT + &quot;.&quot;); 2.新建 mine.js1234567891011121314151617181920exports.types = &#123; &quot;css&quot;: &quot;text/css&quot;, &quot;gif&quot;: &quot;image/gif&quot;, &quot;html&quot;: &quot;text/html&quot;, &quot;ico&quot;: &quot;image/x-icon&quot;, &quot;jpeg&quot;: &quot;image/jpeg&quot;, &quot;jpg&quot;: &quot;image/jpeg&quot;, &quot;js&quot;: &quot;text/javascript&quot;, &quot;json&quot;: &quot;application/json&quot;, &quot;pdf&quot;: &quot;application/pdf&quot;, &quot;png&quot;: &quot;image/png&quot;, &quot;svg&quot;: &quot;image/svg+xml&quot;, &quot;swf&quot;: &quot;application/x-shockwave-flash&quot;, &quot;tiff&quot;: &quot;image/tiff&quot;, &quot;txt&quot;: &quot;text/plain&quot;, &quot;wav&quot;: &quot;audio/x-wav&quot;, &quot;wma&quot;: &quot;audio/x-ms-wma&quot;, &quot;wmv&quot;: &quot;video/x-ms-wmv&quot;, &quot;xml&quot;: &quot;text/xml&quot;&#125;; server.js，接着在里面找到路径设置，把我当前webapp改成你自己的名字项目名称 这两个文件放在项目同级目录可以写项目的相对地址，否则写全路径 三、运行服务1node server.js 在浏览器打开 http://localhost:3000/index.html index.html 为你的项目里的文件]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android知识框架]]></title>
    <url>%2F2019%2F02%2F09%2FAndroid%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[复杂度分析]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[什么是复杂度分析 算法执行时间（或占用空间）与数据规模的增长关系 用时间复杂度和空间复杂度描述性能问题，两者统称复杂度 为什么要进行复杂度分析 和性能测试相比，复杂度分析不依赖执行环境，成本低，效率高，易操作，指导性强 掌握复杂度分析，编写出性能更优的代码 如何表示大O时间复杂度表示法，它其实不具体代码的真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势 所以也叫渐进时间复杂度，简称时间复杂度 时间复杂度分析 只关注循环执行次数最多的一段代码 加法法则，总复杂度等于量级最大的那段代码的复杂度 乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 多个规模求加法，有两个参数控制两个循环的次数，那么这时就取二者复杂度相机 常用的复杂度级别多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。O(1)常数阶，O(logn)对数阶，O(n)线性阶，O(nlogn)线性对数阶，O(n^2)平方阶，O(n^3)立方阶。 复杂度分析的4个概念 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度 平均时间复杂度：代码在所有情况中执行的加权平均值表示 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 课后思考分析下面的add()函数的时间复杂度12345678910111213141516171819202122// 全局变量，大小为 10 的数组 array，长度 len，下标 i。int array[] = new int[10];int len = 10;int i = 0;// 往数组中添加一个元素void add(int element) &#123; if (i &gt;= len) &#123; // 数组空间不够了 // 重新申请一个 2 倍大小的数组空间 int new_array[] = new int[len*2]; // 把原来 array 数组中的数据依次 copy 到 new_array for (int j = 0; j &lt; len; ++j) &#123; new_array[j] = array[j]; &#125; // new_array 复制给 array，array 现在大小就是 2 倍 len 了 array = new_array; len = 2 * len; &#125; // 将 element 放到下标为 i 的位置，下标 i 加一 array[i] = element; ++i;&#125; 最好时间复杂度 O(1) 最坏时间复杂度 O(n) 均摊时间复杂度 O(1) 平均时间复杂度 O(1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解算法]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为什么学习算法 为了写出性能更好的代码 训练大脑，提高大脑思考问题的能力 掌握算法，看待问题的深度，解决问题的角度就会完全不一样 为了解决在计算机计算能力有限下，尽可能提高计算机的处理数据的效率 什么是数据结构，什么是算法数据结构指一组数据的存储结构，算法是操作数据的一组方法 数据结构跟算法的关系数据结构为算法服务，算法作用在特定的数据结构上 学习重点效率和资源消耗的度量衡–复杂的分享 10个数据结构：数组，链表，栈，队列，散列表，二叉树，堆，跳表，图，Trie树 10个算法：递归，排序，二分查找，搜索，哈希算法，贪心算法，分治算法，回溯算法，动态规划，字符串匹配 数据结构与算法学习书单入门《大话数据结构》《算法图解》 经典《算法》《算法导论》 不同编程语言《数据结构和算法分析》 面试《剑指 offer》《编程珠玑》《编程之美》。 殿堂级《计算机程序设计艺术》]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter控件总结]]></title>
    <url>%2F2018%2F12%2F09%2Fflutter%E6%8E%A7%E4%BB%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[标准控件ContainerContainer是一个控件，并且允许您自定义其子控件。 如果要添加内边距，外边距，边框或背景色，可以在创建容器时设置对应的属性值。 添加内边距，外边距和边框 改变背景颜色和背景图像 可以容纳一个子控件，这个控件也可以是 Row 或 Column ，甚至控件树的根结点。 GridView可以将控件布局为可滚动的表格。 在网格中布局控件 检测到垂直内容何时超过渲染框并自动提供滚动 构建您自己的自定义网格，或使用以下框架提供的网格： GridView.count 允许您指定列数 GridView.extent 允许您指定单元格的最大像素宽度 Expanded通过使用 Expanded 控件，可以控件的大小设置为适合行或列 也许你想要一个控件占据其兄弟控件两倍的空间。您可以将行或列的子控件放到 Expanded 控件中，以控制沿着主轴的控件大小。Expanded 控件具有 flex 属性，它是一个整数，用于确定控件的弹性因子。Expanded 控件的默认弹性因子是1。 例如，要创建一个由三个控件组成的行，其中中间控件的宽度是其他两个控件两倍，请将中间控件的弹性系数设置为2： 123456789101112131415appBar: new AppBar( title: new Text(widget.title),),body: new Center( child: new Row( crossAxisAlignment: CrossAxisAlignment.center, children: [ new Expanded( child: new Image.asset(&apos;images/pic1.jpg&apos;), ), new Expanded( flex: 2, child: new Image.asset(&apos;images/pic2.jpg&apos;), ), new Expanded( ListView可以将控件布局为可滚动的列表。 Stack可以将控件覆盖到另一个控件上 Material组件Card可以在带圆角和投影的盒子中进行布局。 ListTile包括三行文本，可选图标和标题 ListTile 是 Material 组件库中的一个专门的行控件，用于创建包含最多3行文本和可选的前导和尾随图标的行。 ListTile 在Card 或 ListView 中最常用，但也可以在别处使用。 ListTile 总结: 包含最多3行文本和可选图标的专用行 比 Row 更少的配置，但更易于使用 来自 Material 组件库]]></content>
      <categories>
        <category>flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 高清加载巨图方案 拒绝压缩图片]]></title>
    <url>%2F2018%2F11%2F21%2F%E6%8B%92%E7%BB%9D%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[对于加载图片，大家都不陌生，一般为了尽可能避免OOM都会按照如下做法： 对于图片显示：根据需要显示图片控件的大小对图片进行压缩显示。如果图片数量非常多：则会使用LruCache等缓存机制，将所有图片占据的内容维持在一个范围内。 首先不压缩，按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类： BitmapRegionDecoder 初识BitmapRegionDecoderBitmapRegionDecoder主要用于显示图片的某一块矩形区域，如果你需要显示某个图片的指定区域，那么这个类非常合适。 对于该类的用法，非常简单，既然是显示图片的某一块区域，那么至少只需要一个方法去设置图片；一个方法传入显示的区域即可；详见： BitmapRegionDecoder提供了一系列的newInstance方法来构造对象，支持传入文件路径，文件描述符，文件的inputstrem等。12BitmapRegionDecoder bitmapRegionDecoder = BitmapRegionDecoder.newInstance(inputStream, false); 上述解决了传入我们需要处理的图片，那么接下来就是显示指定的区域。 1bitmapRegionDecoder.decodeRegion(rect, options); demo:123456789101112131415161718192021222324252627282930313233343536373839public class LargeImageViewActivity extends AppCompatActivity&#123; private ImageView mImageView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_large_image_view); mImageView = (ImageView) findViewById(R.id.id_imageview); try &#123; InputStream inputStream = getAssets().open(&quot;tangyan.jpg&quot;); //获得图片的宽、高 BitmapFactory.Options tmpOptions = new BitmapFactory.Options(); tmpOptions.inJustDecodeBounds = true; BitmapFactory.decodeStream(inputStream, null, tmpOptions); int width = tmpOptions.outWidth; int height = tmpOptions.outHeight; //设置显示图片的中心区域 BitmapRegionDecoder bitmapRegionDecoder = BitmapRegionDecoder.newInstance(inputStream, false); BitmapFactory.Options options = new BitmapFactory.Options(); options.inPreferredConfig = Bitmap.Config.RGB_565; Bitmap bitmap = bitmapRegionDecoder.decodeRegion(new Rect(width / 2 - 100, height / 2 - 100, width / 2 + 100, height / 2 + 100), options); mImageView.setImageBitmap(bitmap); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Activity的启动模式以及使用场景]]></title>
    <url>%2F2018%2F11%2F21%2FActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[#启动模式 standard默认的启动模式 压栈 singleTop一个singleTop Activity 的实例可以无限多，唯一的区别是如果在栈顶已经有一个相同类型的Activity实例，Intent不会再创建一个Activity，而是通过onNewIntent()被发送到现有的Activity。 singleTask这种模式和standard以及singleTop有很大不同。singleTask模式的Activity只允许在系统中有一个实例。如果系统中已经有了一个实例，持有这个实例的任务将移动到顶部，同时intent将被通过onNewIntent()发送。如果没有，则会创建一个新的Activity并置放在合适的任务中。 singleInstance会开启新的任务栈在任务栈里面只有一个存在因为这个任务只有一个Activity，我们再也无法切回到任务#1了。唯一的办法是重新在launcher中启动这个应用。 but之后的没有翻译，因为我也不明白作者的意思。 不过这个问题也有解决方案，就像我们在singleTask Acvity中做的，只要为singleInstance Activity设置taskAffinity属性就可以了。12345&lt;activity android:name=&quot;.SingleInstanceActivity&quot; android:label=&quot;singleInstance launchMode&quot; android:launchMode=&quot;singleInstance&quot; android:taskAffinity=&quot;&quot;&gt; 以上通过AndroidManifest 在Android开发中，Intent想必大家经常用。Intent本意为目的、意向、意图。在Android中，Intent是系统各组件（或应用程序）之间进行数据传递的数据附载者，Intent不仅可以用于应用程序之间的交互，也可以用于应用程序内部的Activity、Service和Broadcast Receiver之间的交互。 解读Android Intent。本文主要说的是Intent的Flag标志。 TaskTask就是一个任务栈，里面用来存放Activity，第一个进去的（Activity）处于栈的最下面，而最后创建的（Activity）则处于栈的最上面。从Task中取出（Activity）是从最顶端取出，也就是说先进后出，后进先出。而Activity在Task中的顺序是可以控制的，在Activity跳转时用到Intent Flag可以设置新建Activity的创建方式。 FLAG_ACTIVITY_BROUGHT_TO_FRONT这个Flag的意思，比如我现在有一个A，然后在A中启动B，并设置FLAG_ACTIVITY_BROUGHT_TO_FRONT这个启动标记，那么B就是以FLAG_ACTIVITY_BROUGHT_TO_FRONT启动的。然后在B中启动C，此时栈就是A,B,C。如果这个时候在C中启动B，那么栈的情况会是A,C,B。 FLAG_ACTIVITY_REORDER_TO_FRONT如果在栈中有A,B,C三个Activity，并且是正常启动的，此时在C中启动B的话，还是会变成A,C,B的。 如果使用了标志 FLAG_ACTIVITY_CLEAR_TOP，那这个FLAG_ACTIVITY_REORDER_TO_FRONT标志会被忽略。 FLAG_ACTIVITY_NEW_TASK假设现在有一个栈1，里面是A,B,C。此时，在C中启动D的时候，设置FLAG_ACTIVITY_NEW_TASK标记，此时会有两种情况： 1.如果D这个Activity在Manifest.xml中的声明中添加了Task Affinity，系统首先会查找有没有和D的Task Affinity相同的Task栈存在，如果有存在，将D压入那个栈2.如果D这个Activity在Manifest.xml中的Task Affinity默认没有设置，则会把其压入栈1，变成：A B C D，这样就和标准模式效果是一样的了。也就是说，设置了这个标志后，新启动的Activity并非就一定在新的Task中创建，如果A和B在属于同一个package，而且都是使用默认的Task Affinity，那B还是会在A的task中被创建。 所以，只有A和B的Task Affinity不同时，设置了这个标志才会使B被创建到新的Task。注意如果试图从非Activity的非正常途径启动一个Activity，比如从一个Receiver中启动一个Activity，则Intent必须要添加FLAG_ACTIVITY_NEW_TASK标记。 FLAG_ACTIVITY_CLEAR_TASK如果Intent中设置了这个标志，会导致含有待启动Activity的Task在Activity被启动前清空。也就是说，这个Activity会成为一个新的root，并且所有旧的activity都被finish掉。这个标志只能与FLAG_ACTIVITY_NEW_TASK 一起使用。 FLAG_ACTIVITY_SINGLE_TOP这个FLAG就相当于加载模式中的singleTop，比如说原来栈中情况是A,B,C,D在D中启动D，栈中的情况还是A,B,C,D。 FLAG_ACTIVITY_CLEAR_TOP这个FLAG就相当于加载模式中的SingleTask，如果启动的Activity存在当前的栈中，系统会把要启动的Activity之上的Activity全部弹出栈空间，然后把Intent作为一个新的Intent传给这个Activity。 例如：原来栈中的情况是A,B,C,D这个时候从D中跳转到B，这个时候栈中的情况就是A,B了。上面例子中运行的B activity既可以在onNewIntent()中接收新的Intent，也可以将自己finish掉然后使用新的Intent重启。如果在它的launch mode中设置了”multiple”（默认），并且intent中没有设置 FLAG_ACTIVITY_SINGLE_TOP 标志，那它就会被finish掉然后重新创建。如果是其它的launchMode或者是设置了FLAG_ACTIVITY_SINGLE_TOP 属性，那就会使用现有的实例的OnNewIntent()方法来接受Intent。 这种启动模式也可以与 FLAG_ACTIVITY_NEW_TASK 一起使用：如果用来启动一个任务的root activity，它会将这个任务中现在运行的实例调到前台，然后将任务清空至只有根Activity的状态。这很有用，例如要从通知中心里启动一个Activity时。 FLAG_ACTIVITY_NO_HISTORY用这个FLAG启动的Activity，一但退出，就不会存在于栈中。栈中是A,B,C 这个时候再C中以这个FLAG启动D的，D再启动E，这个时候栈中情况为A,B,C,E。简而言之，跳转到的activity不压在栈中。 FLAG_ACTIVITY_NO_USER_ACTION如果设置了这个标志，可以在避免用户离开当前Activity时回调到 onUserLeaveHint()。通常，Activity可以通过这个回调表明有明确的用户行为将当前Activity切出前台。这个回调标记了Activity生命周期中的一个恰当的点，可以用来“在用户看过通知之后”将它们清除，如闪烁LED灯。 如果Activity是由非用户驱动的事件（如电话呼入或闹钟响铃）启动的，那这个标志就应该被传入Context.startActivity，以确保被打断的Activity不会认为用户已经看过了通知。 以下内容是根据文档和网上查看的FLAG(目的是为了把FLAG总结在一起) FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET设置这个标志意味着在activity栈中做一个标记，在Task重置的时候栈就把从标记往上的activity都清除。也就是说，下次这个Task被通过FLAG_ACTIVITY_RESET_TASK_IF_NEEDED调到前台时（通常是由于用户从桌面重新启动），这个activity和它之上的activity都会被finish掉，这样用户就不会再回到他们，而是直接回到在它们之前的activity。 这在应用切换时非常有用。比如，Email应用会需要查看附件，就要调用查看图片的Activity来显示，那这个查看图片的Activity就会成为Email应用任务里的一部分。但是，如果用户离开了Email的任务，过了一会儿由通过Home来选择Email应用，我们会希望它回到查看邮件会话的页面，而不是浏览图片附件的页面，不然就感觉太诡异了。如果在启动查看图片Activity时设置了这个标志，那这个Activity及由它启动的Activity在下一次用户返回邮件时都会被清除。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS如果设置这个标志，这个Activity就不会在近期任务中显示。 FLAG_ACTIVITY_FORWARD_RESULT如果Activity A 在启动 Activity B时设置了这个标志，那A的答复目标目标会传递给B，这样一来B就可以通过调用setResult(int) 将返回结果返回给A的答复目标。 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY这个标志通常情况下不会通过应用的代码来设置，而是在通过最近任务启动activity时由系统设置的。 FLAG_ACTIVITY_NO_ANIMATION禁用掉系统默认的Activity切换动画。 FLAG_ACTIVITY_TASK_ON_HOME这个标志可以将一个新启动的任务置于当前的home任务(home activity task)之上（如果有的话）。也就是说，在任务中按back键总是会回到home界面，而不是回到他们之前看到的activity。这个标志只能与FLAG_ACTIVITY_NEW_TASK标志一起用。 比如，A-&gt;B-&gt;C-&gt;D，如果在C启动D的时候设置了这个标志，那在D中按Back键则是直接回到桌面，而不是C。 注意:只有D是在新的task中被创建时（也就是D的launchMode是singleInstance时，或者是给D指定了与C不同的taskAffinity并且加了FLAG_ACTIVITY_NEW_TASK标志时），使用 FLAG_ACTIVITY_TASK_ON_HOME标志才会生效。 感觉实际使用效果和用 FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK 的效果一样。 FLAG_FROM_BACKGROUND可以给调用者用来标识这个Intent是来自后台操作，而不是用户的交互行为。 FLAG_RECEIVER_FOREGROUND当发送广播的时候设置了这个标志，会允许接收者以前台的优先级运行，有更短的时间间隔。正常广播的接受者是后台优先级，不会被自动提升。 FLAG_RECEIVER_REPLACE_PENDING如果在发送广播时设置了这个标志，那新的广播会替换掉那些已存在的相同广播。相同的定义是通过Intent.filterEquals方法对两个广播的Intent处理返回true。 当匹配到相同的，新的广播和对应的接收器会将待发送的广播列表中已存在的替换掉，在列表中保留同样的位置。这个标志通常被粘性广播(Sticky Broadcast)使用，只保证将最新的广播的值传递给接收器。 应用场景：singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建。 singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android的Service]]></title>
    <url>%2F2018%2F11%2F20%2FAndroid%E7%9A%84Service%2F</url>
    <content type="text"><![CDATA[Android 服务两种启动方式的区别Service是Android四大组件之一，也是可执行的程序，有自己的生命周期。创建、配置Service和创建、配置Activity的过程相似。和Activity一样，都是从Context派生出来的。 1. 采用start的方式开启服务12341.定义一个类继承Service2.在Manifest.xml文件中配置该Service3.使用Context的startService(Intent)方法启动该Service4.不再使用时，调用stopService(Intent)方法停止该服务 说明：如果服务已经开启，不会重复的执行onCreate()， 而是会调用onStart()和onStartCommand()。服务停止的时候调用 onDestory()。服务只会被停止一次。 特点：一旦服务开启跟调用者(开启者)就没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面的方法。 2. Service的第二种启动方式采用bind的方式开启服务12341.定义一个类继承Service2.在Manifest.xml文件中配置该Service3.使用Context的bindService(Intent, ServiceConnection, int)方法启动该Service4.不再使用时，调用unbindService(ServiceConnection)方法停止该服务 绑定本地服务调用方法的步骤： 在服务的内部创建一个内部类 提供一个方法，可以间接调用服务的方法 实现服务的onbind方法，返回的就是这个内部类 在activity 绑定服务。bindService(); 在服务成功绑定的回调方法onServiceConnected， 会传递过来一个 IBinder对象 强制类型转化为自定义的接口类型，调用接口里面的方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android的BroadcastReceiver]]></title>
    <url>%2F2018%2F11%2F20%2FAndroid%E7%9A%84BroadcastReceiver%2F</url>
    <content type="text"><![CDATA[一.注册广播在android中，我们如果想接收到广播信息，必须自定义我们的广播接收者。要写一个类来继承BroadcastReceiver，并且重写其onReceive()方法，实现接收到特定广播所要做的事情。这是一个自定义的广播接收者：123456789public class MyBroadCastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //在这里可以写相应的逻辑来实现一些功能 //可以从Intent中获取数据、还可以调用BroadcastReceiver的getResultData()获取数据 &#125; &#125; 我们已经定义好了一个广播接收者。要想使用它接受到广播，就要注册这个广播接收者。 1.代码中动态注册实例化自定义的广播接收者实例化意图过滤器，并设置要过滤的广播类型（如，我们接收收到短信系统发出的广播）使用Context的registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)方法注册广播1234567891011121314//new出上边定义好的BroadcastReceiverMyBroadCastReceiver yBroadCastReceiver = new MyBroadCastReceiver();//实例化过滤器并设置要过滤的广播 IntentFilter intentFilter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);//注册广播 myContext.registerReceiver(smsBroadCastReceiver,intentFilter, &quot;android.permission.RECEIVE_SMS&quot;, null);作者：食梦兽链接：https://www.jianshu.com/p/ea5e233d9f43來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.在Manifest.xml中静态注册直接在Manifest.xml文件的节点中配置广播接收者。123456 &lt;receiver android:name=&quot;.MyBroadCastReceiver&quot;&gt; &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt; &lt;intent-filter android:priority=&quot;20&quot;&gt; &lt;actionandroid:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 还要在同级的位置配置可能使用到的权限12&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;&gt;&lt;/uses-permission&gt; 两种注册广播的不同第一种不是常驻型广播，也就是说广播跟随程序的生命周期。第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 二.发送广播有两种方式分别发送两种不同的广播：通过mContext.sendBroadcast(Intent)或mContext.sendBroadcast(Intent, String)发送的是无序广播(后者加了权限)；通过mContext.sendOrderedBroadcast(Intent, String, BroadCastReceiver, Handler, int, String, Bundle)发送的是有序广播。 区别：无序广播：所有的接收者都会接收事件，不可以被拦截，不可以被修改。有序广播：按照优先级，一级一级的向下传递，接收者可以修改广播数据，也可以终止广播事件。 1.无序广播定义一个按钮，设置其点击事件，发送一个无序广播。12345Intent intent = new Intent();//设置intent的动作为com.example.broadcast，可以任意定义intent.setAction(&quot;com.example.broadcast&quot;);//发送无序广播sendBroadcast(intent); 定义一个广播接收者，来接收这个广播事件。通过Toast的打印判断是否收到广播 12345678public class MyReceiver extends BroadcastReceiver &#123; public MyReceiver() &#123; &#125; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,&quot;收到广播&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 在Manifest.xml中配置该接收者。1234567&lt;receiver android:name=&quot;.MyReceiver&quot; &gt; &lt;intent-filter&gt; &lt;!-- 动作设置为发送的广播动作 --&gt; &lt;action android:name=&quot;com.example.broadcast&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 运行结果为：Toast打印出 “收到广播”。 1.有序广播和无序广播使用不同的是 通过 mContext.sendOrderedBroadcast(Intent, String, BroadCastReceiver, Handler, int, String, Bundle)和每个接收者设置优先级，就可以在小于自己优先级的接收者得到广播前，修改或终止广播。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849定义一个按钮，设置其点击事件，发送一个有序广播。 Intent intent = new Intent(); //设置intent的动作为com.example.broadcast，可以任意定义 intent.setAction(&quot;com.example.broadcast&quot;); //发送无序广播 //第一个参数：intent //第二个参数：String类型的接收者权限 //第三个参数：BroadcastReceiver 指定的接收者 //第四个参数：Handler scheduler //第五个参数：int 此次广播的标记 //第六个参数：String 初始数据 //第七个参数：Bundle 往Intent中添加的额外数据 sendOrderedBroadcast(intent, null, null, null, &quot;这是初始数据&quot;, );定义多个广播接收者，来接收这个广播事件。通过Toast的打印判断是否收到广播public class MyReceiver1 extends BroadcastReceiver &#123; public MyReceiver1() &#123; &#125; @Override public void onReceive(Context context, Intent intent) &#123; //获取广播中的数据（即得到 &quot;这是初始数据&quot; 字符串） String message = getResultData(); Toast.makeText(context ,message ,Toast.LENGTH_SHORT).show(); //修改数据 setResultData(&quot;这是修改后的数据&quot;); &#125;&#125;public class MyReceiver2 extends BroadcastReceiver &#123; public MyReceiver2() &#123; &#125; @Override public void onReceive(Context context, Intent intent) &#123; String message = getResultData(); Toast.makeText(context ,message ,Toast.LENGTH_SHORT).show(); //终止广播 abortBroadcast(); &#125;&#125;public class MyReceiver3 extends BroadcastReceiver &#123; public MyReceiver3() &#123; &#125; @Override public void onReceive(Context context, Intent intent) &#123; String message = getResultData(); Toast.makeText(context ,message ,Toast.LENGTH_SHORT).show(); &#125;&#125; 在Manifest.xml中配置该接收者。并设置优先级：MyReceiver1&gt;MyReceiver2&gt;MyReceiver3。12345678910111213141516171819202122232425&lt;!-- 优先级相等的话，写在前面的receiver的优先级大于后面的 --&gt;&lt;receiver android:name=&quot;.MyReceiver1&quot; &gt; &lt;!-- 定义广播的优先级 --&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;!-- 动作设置为发送的广播动作 --&gt; &lt;action android:name=&quot;com.example.broadcast&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.MyReceiver2&quot; &gt; &lt;!-- 定义广播的优先级 --&gt; &lt;intent-filter android:priority=&quot;0&quot;&gt; &lt;!-- 动作设置为发送的广播动作 --&gt; &lt;action android:name=&quot;com.example.broadcast&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.MyReceiver3&quot; &gt; &lt;!-- 定义广播的优先级 --&gt; &lt;intent-filter android:priority=&quot;-1000&quot;&gt; &lt;!-- 动作设置为发送的广播动作 --&gt; &lt;action android:name=&quot;com.example.broadcast&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 运行结果：MyReceiver1得到广播数据后打印“这是初始数据”，MyReceiver2接收到广播数据打印“这是修改后的数据”，MyReceiver3没有打印。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收算法]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常见的垃圾回收算法 1.引用计数法给对象加上一个引用计数器，每当有地方引用它的时候计数器数值就加1，引用失效的时候，计数器就减1，任何时候引用计数器为0，对象就不再被使用，垃圾回收器将回收该对象的内存 引用计数器算法对于对象直接的循环引用问题难以解决，因此java并没有使用 2.根搜索法通过一些列成为GCroot的对象为起点，这些结点向下搜索，搜索过的路径成为引用链，当一个对象没有任何引用链的时候，则对象不可达不可用，被垃圾回收器回收 java GCRoot对象1.java 虚拟机栈中的引用对象2.方法区内类的静态属性引用对象3.方法区内常量引用对象4.本地方法栈Jni引用对象 判读无用的常量如果某个常量没有被任何对象引用 判断无用的类： 1。类的所有实例被回收 类加载器被回收 该类对象的java.lang.Class 对象没有被任何地方引用（反射） java 常见回收算法 标记清理算法 首先标记出需要所有需要回收的对象，标记完成后统一清除 缺点： 标记跟清除的效率都不高 标记清除后会产生大量的是不连续的内存碎片，导致当程序分配大内存对象 无法找到连续内存，而不得不触发另一次垃圾回收 复制算法将内存可用区域分成大小相等的两块，每次使用一部分内存区域，这块内存用完了，将还存活的对象复制到另一块内存区域，再一次性清理掉那块内存，这样使得每一次对一块内存区域做回收，复制分配内存的时候不用考虑内存碎片的问题，只需要一定堆顶的指针，按顺序分配内存，简单实现，高效 缺点：将内存降为原来的一半 标记整理算法跟标记清除算法类型，标记出需要回收的对象，但是标记完不是直接清理，而是让所有存活的对象向一端移动，在移动的过程中清除标记的对象 优点：相比标记清除算法不会产生大量的内存碎片 相对复制算法，在有大对象存活率高的情况下，复制算法效率很低，标记整理算法效率就会很高 分代回收算法java虚拟机将内存区域氛围]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类加载过程]]></title>
    <url>%2F2018%2F07%2F12%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[类加载过程其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。 7个阶段 加载 验证 准备 解析 初始化 使用 卸载 类加载器的任务就是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。 BootstrapClassLoader、ExtClassLoader和AppClassLoaderdefineClass方法将字节码的byte数组转换为一个类的class对象实例，如果希望在类被记载到JVM时就被链接，那么可以调用resolveClass方法。 BootStrap –&gt; JRE/lib/rt.jar ExtClassLoader –&gt; JRE/lib/rt.jar AppClassLoader –&gt; classPath制定的所有jar的路径 MyCalssLoader 双亲委托模型：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委托给父类加载器去完成，m,每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的类加载起加载，只有父类加载起反馈自己无法完成这个加载请求的时候，子加载器才会尝试自己去加载 实现：双亲委托的代码都集中在java.lang.ClassLoader 的loadClass（）方法，逻辑清晰易懂，先检查是否被加载过若没有则调用父类加载器的loadClass方法，若父类加载器为空则默认使用 如果父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法进行加载 加载：类加载器读取类的二进制字节流到JVM内部，存储在运行时方法区 链接:要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中 验证验证类数据是否是有效的字节吗文件，包含格式验证，语义分析，操作验证 准备为类中单饿所有静态变量分配内存空间，被final 修饰的静态变量会直接赋值类字段的字段属性表存在constantValue属性 解析将常量池中的符号引用转为直接引用，这个可以 可以认为是一些静态绑定的会被解析，动态绑定则会在运行时进行解析，静态绑定一些final方法，static，构造器 初始化将一个类中所有被static 关键字标识的代码统一执行一遍，如果执行的是静态变量， 使用卸载]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2F2018%2F07%2F09%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.程序计数器在Jvm中，多线程是通过线程轮流切换获得cpu的执行时间的，为了使得每个线程在切换后能够恢复到切换之前的程序执行位置，每个线程需要有自己独立的程序计数器，并且不能互相被干扰，否则会影响程序的正常执行顺序，因此程序计数器是每个线程私有的，程序计数器存储的数据不会随着程序的执行而改变，这块区域是唯一没有被定义有oom的 在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。 2.方法区，存储加载的类信息，常量和静态变量，即时编译器编译后的代码等数据，是各个线程共享的 运行时常量池(Runtime Constant Pool)：属于方法区的一部分，用于存放编译期间生成的各种符号引用，这部分将在类加载后放到方法区的运行时常量池。 在运行期间也可能有新的常量放入常量池中，例如通过String.intern()方法。 3.java栈4.堆java中的对象分配内存空间的区域，可以被所有线程共享 5.native栈存放native方法的栈]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hashMap]]></title>
    <url>%2F2018%2F07%2F08%2FhashMap%2F</url>
    <content type="text"><![CDATA[HashMap什么是HashMapHashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射 为什么使用HashMap HashMap 采用了数组和链表的数据结构，极大限度发挥了数组和链表的优势 HashMap 是非同步的速度很快 HashMap 可以接受null的key 和value HashMap的工作原理HashMap是基于hashing的原理，添加数据的时候调用hashCode()方法，找到存储的位置，存储对象，然后获取数据的时候也是进行hashCode，然后找到存储的位置找到对象 HashMap的put过程 对key进行hash,然后计算出下标 如果没有碰撞直接放入桶内 如果碰撞了，以链表的方式放到后面 如果链表长度超过8，就把链表转成链表，链表长度低于6的时候再把红黑树转成链表 如果结点已经存在，则替换之前的 如果数据数量到达到桶的*0.75（加载因子），就需要resize 有什么方法可以减少碰撞 扰动函数可以减少碰撞，如果两个不相等的对象返回的hashcode值不一致，那么碰撞的几率就很小（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。） 使用不可变的、声明作final的对象并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得缓存不同键的hashcode,提高获取整个对象的速度使用String，Interger这样的wrapper类作为键是非常好的选择。 为什么String, Interger这样的wrapper类适合作为键？ 因为String 是fianl的，而且已经重写了equals()和hashcode方法，不可变性是必要的防止put get不一致导致取不出。 HashMap 中的hash函数是怎么实现的 用hashcode 对数组的长度取余 1.8 123456789 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; h=hashCode():1111 1111 1111 1111 1111 0000 1110 1010--- h : 1111 1111 1111 1111 1111 0000 1110 1010 h&gt;&gt;&gt;16: 0000 0000 0000 0000 1111 1111 1111 1111 tableSizeFor123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity，由于HashMap的capacity都是2的幂，因此这个方法用于找到大于等于initialCapacity的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。 两个对象Hashcode 相同连个对象hashcode说明他们的bucket位置相同，这就发生了碰撞，hashMap 解决hash冲突的方法是链地址法，会把对象存入链表，在jdk1.8上当链表长度达到8的时候，会转成红黑树，因为冲突数量多的话，那么链表的查询时间复杂啊的为O(m),红黑树是logn,红黑树是一种平衡二叉树，不是绝对的平衡，相对的平衡 红黑树定义：1.跟节点是黑色的2.每个叶子结点是黑色的空结点，也就是说叶子结点不存储数据3.任何相邻的结点不同为红色，也就是说红色结点被黑色结点隔开的4.每个结点到达可达结点的所有路径都包含相同数目的黑色结点 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？ 二叉树会在特殊情况下变成一条线性结构，这个跟原来链表一样了，遍历查找就会很慢，红黑树是平衡二叉树，随着结点增加，查找复杂度O(nlgN),通过左右旋，保持平衡，左右，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢 #### 两个键的hashcode相同如何获得值对象get()方法根据hashcode 找到bucket的位置，如果这个bucket存有多个数据将会遍历链表找到值的对象，]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
